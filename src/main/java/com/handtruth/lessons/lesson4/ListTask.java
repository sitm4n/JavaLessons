package com.handtruth.lessons.lesson4;

import java.util.ArrayList;
import java.util.List;

class ListTask {

    /**
     * Easy
     * <p>
     * Найти количество неотрицательных элементов списка
     */
    int positiveCounter(List<Integer> list) {
        // TODO your code
        return 0;
    }

    /**
     * Easy
     * <p>
     * Найти максимальный элемент в списке
     * (Гарантируется, что список не пустой)
     */
    int maxNumber(List<Integer> list) {
        // TODO your code
        return 0;
    }

    /**
     * Medium (для нахождения решения за линейное время)
     *
     * Найти все схожие элементы в списках
     * (все элементы отсортированы по возрастанию)
     */
    List<Integer> items(List<Integer> list1, List<Integer> list2) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     *
     * Отсортировать входной спписок по возрастанию методом пузырьков
     * (алгоритм реализовать самостоятельно)
     */
    List<Integer> simpleSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     *
     * Отсортировать входной список по возрастанию с помощью Merge Sort
     * (алгоритм реализовать самостоятельно)
     */
    List<Integer> mergeSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     *
     * Отсортировать входной список по возрастанию с помощью Quick Sort
     * (алгоритм реализовать самостоятельно!)
     */
    List<Integer> quickSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     *
     * Даны числа от 1 до 100
     * Отсортировать входной список по возрастанию
     * (линейное время)
     */
    List<Integer> linearSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }
    
    /**
     * Hard 
     *
     * Дан список содержащий значения типа Boolean (не null).
     * Необходимо найти наиболее длинную последовательность значений true. 
     * Если посреди последовательности true встреается значение false (только одно и только один раз),
     * его можно проигнорировать и считать последовательность непрерывной (в длину такой последовательности не входит false).
     * Известно, что есть решение за линейное время :)
     *
     * Пример :  
     * на входе - {T,T,T,F,T,T,F,F,T,T,T,T}
     * ответ - 5
     *
     */
    Integer longestTrueSequence (List<Boolean> list) {
        // TODO your code
        return 0;
    }
}
